<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Model Viewer (Three.js AR)</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://use.typekit.net/zfi8dmc.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap">

    <style>
        /* ... (your existing CSS) ... */
    </style>
</head>
<body>
    <div id="container"></div>

    <div id="fixedUI">
        <a href="newMenu.html">
            <img class="return" src="icon/returnbtn.png" alt="return">
        </a>
        <img class="specification" src="icon/infobtn.png" alt="specification" id="specButton">
    </div>

    <div id="arOverlay" class="ar-overlay">
        <div class="loadingText">
            <img src="icon/explanation.png">
        </div>
    </div>

    <div class="spec-overlay" id="specOverlay">
        <h2>製品仕様</h2>
        <p>・概要 逆円錐型のケーシング内で回転するパドルによって 粉体に強力な衝撃・せん断力を与え、攪拌・分散し、 精密混合を行うバッチ式の高速せん断型混合機です。 ・特長 短い時間で均一な混合が可能</p>
        <a id="modelLink" href="#" target="_blank">製品仕様</a>
        <div id="iframeWrapper">
            <button id="closeIframeBtn">×</button>
            <iframe title="model" id="modelIframe"></iframe>
        </div>
        <img src="icon/returnbtn.png" class="close-spec" id="closeSpec">
    </div>

    <button id="screenshotButton" class="ar-control-button" style="display:none;">Take Screenshot</button>

    <script type="module">
        // Change these import paths to the full CDN URLs
        import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';
        import { GLTFLoader } from 'https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js';
        import { ARButton } from 'https://unpkg.com/three@0.165.0/examples/jsm/webxr/ARButton.js';

        let camera, scene, renderer;
        let model;
        let hitTestSource = null;
        let hitTestSourceRequested = false;

        const fixedUI = document.getElementById('fixedUI');
        const arOverlay = document.getElementById('arOverlay');
        const screenshotButton = document.getElementById('screenshotButton');
        const specButton = document.getElementById('specButton');
        const specOverlay = document.getElementById('specOverlay');
        const closeSpec = document.getElementById('closeSpec');
        const modelLink = document.getElementById('modelLink');
        const iframeWrapper = document.getElementById('iframeWrapper');
        const modelIframe = document.getElementById('modelIframe');
        const closeIframeBtn = document.getElementById('closeIframeBtn');

        let arJustStarted = false;
        let arTimeout = null;

        const dots = [];
        const dimLines = [];

        init();
        animate();

        function init() {
            const container = document.getElementById('container');

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Ensure sRGBEncoding for correct colors if your textures are sRGB
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            const arBtn = ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] });
            arBtn.textContent = "Enter AR";
            arBtn.id = 'arEntranceButton';
            document.body.appendChild(arBtn);

            arBtn.style.display = 'block';
            fixedUI.style.display = 'flex';

            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);

            // Add a temporary AxesHelper for debugging
            const axesHelper = new THREE.AxesHelper( 0.5 ); // A bit smaller for AR context
            scene.add( axesHelper );


            const urlParams = new URLSearchParams(window.location.search);
            const modelUrl = urlParams.get('model');
            const modelKey = modelUrl ? modelUrl.split('/').pop().split('.')[0] : "";

            if (modelUrl) {
                loadModel(modelUrl);
                updateSpecificationOverlay(modelKey);
            } else {
                console.warn("No model URL provided in the query string (e.g., ?model=models/your_model.glb). Loading default.");
                loadModel('models/default_model.glb'); // Ensure you have this default model
                updateSpecificationOverlay('default_model'); // And a spec for it
            }

            window.addEventListener('resize', onWindowResize);

            renderer.xr.addEventListener('sessionstart', function () {
                console.log('AR session started');
                fixedUI.style.display = 'none';
                arBtn.style.display = 'none';

                arOverlay.style.display = 'flex';
                arJustStarted = true;
                arTimeout = setTimeout(() => {
                    arOverlay.style.display = 'none';
                    arJustStarted = false;
                    screenshotButton.style.display = 'block';
                }, 5000);
            });

            renderer.xr.addEventListener('sessionend', function () {
                console.log('AR session ended');
                arOverlay.style.display = 'none';
                arJustStarted = false;
                clearTimeout(arTimeout);
                screenshotButton.style.display = 'none';
                fixedUI.style.display = 'flex';
                arBtn.style.display = 'block';
                hitTestSourceRequested = false;
                hitTestSource = null;

                // Reset model position/placement state when AR session ends
                if (model) {
                    model.userData.isPlaced = false;
                    model.position.set(0, 0, 0); // Or move it off-screen
                    // Consider removing model from scene and re-adding on next AR session
                    // if you want a fresh placement
                }
            });

            arOverlay.addEventListener('click', () => {
                if (arJustStarted) {
                    clearTimeout(arTimeout);
                    arOverlay.style.display = 'none';
                    arJustStarted = false;
                    screenshotButton.style.display = 'block';
                }
            });

            screenshotButton.addEventListener('click', () => {
                renderer.domElement.toDataURL('image/png').then(dataUrl => {
                    const link = document.createElement('a');
                    link.href = dataUrl;
                    link.download = `ar_screenshot_${Date.now()}.png`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }).catch(err => {
                    console.error("Failed to take screenshot:", err);
                    alert("Failed to take screenshot.");
                });
            });

            specButton.addEventListener('click', () => {
                specOverlay.style.display = 'flex';
            });

            closeSpec.addEventListener('click', () => {
                specOverlay.style.display = 'none';
                iframeWrapper.style.display = 'none';
                modelIframe.src = "";
            });

            closeIframeBtn.addEventListener('click', () => {
                iframeWrapper.style.display = 'none';
                modelIframe.src = '';
            });
        }

        function loadModel(url) {
            const loader = new GLTFLoader();
            loader.load(
                url,
                function (gltf) {
                    if (model) {
                        scene.remove(model); // Remove previous model if any
                    }
                    model = gltf.scene;
                    scene.add(model);

                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const center = box.getCenter(new THREE.Vector3());

                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scaleFactor = 0.5 / maxDim; // Scale largest dimension to 0.5 meters
                    model.scale.setScalar(scaleFactor);

                    // Re-center model pivot *after* scaling, then set a default position
                    box.setFromObject(model); // Recalculate bounding box after scaling
                    box.getCenter(center);
                    model.position.sub(center); // Move model's center to its local origin

                    // Initialize model as not placed, it will be positioned by AR hit test
                    model.userData.isPlaced = false;

                    // For non-AR fallback or initial visibility before placement:
                    // model.position.set(0, 0, -1); // Place 1 unit in front of the camera

                    console.log('Model loaded and scaled:', url, 'New size:', model.scale);
                },
                function (xhr) {
                    console.log((xhr.loaded / xhr.total * 100) + '% loaded');
                },
                function (error) {
                    console.error('An error occurred loading the model:', error);
                    alert(`Failed to load model: ${url}. Please ensure the file exists and is valid.`);
                }
            );
        }

        async function updateSpecificationOverlay(modelKey) {
            try {
                const response = await fetch('modelSpecs.json');
                const modelSpecs = await response.json();

                if (modelKey && modelSpecs[modelKey]) {
                    const spec = modelSpecs[modelKey];
                    specOverlay.querySelector('h2').innerHTML = spec.title;
                    specOverlay.querySelector('p').innerHTML = spec.description;

                    if (spec.link) {
                        modelLink.style.display = 'inline';
                        modelLink.onclick = (e) => {
                            e.preventDefault();
                            modelIframe.src = spec.link;
                            iframeWrapper.style.display = 'block';
                        };
                    } else {
                        modelLink.style.display = 'none';
                        iframeWrapper.style.display = 'none';
                    }
                } else {
                    specOverlay.querySelector('h2').textContent = "仕様情報がありません";
                    specOverlay.querySelector('p').textContent = "このモデルの仕様はまだ登録されていません。";
                    modelLink.style.display = 'none';
                    iframeWrapper.style.display = 'none';
                }
            } catch (error) {
                console.error("Error loading modelSpecs.json:", error);
                specOverlay.querySelector('h2').textContent = "エラー";
                specOverlay.querySelector('p').textContent = "仕様情報の読み込みに失敗しました。";
                modelLink.style.display = 'none';
                iframeWrapper.style.display = 'none';
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (!hitTestSourceRequested) {
                    session.requestReferenceSpace('viewer').then(function (viewerSpace) {
                        session.requestHitTestSource({ space: viewerSpace }).then(function (source) {
                            hitTestSource = source;
                        });
                    });

                    session.addEventListener('end', function () {
                        hitTestSourceRequested = false;
                        hitTestSource = null;
                    });
                    hitTestSourceRequested = true;
                }

                if (hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);

                    if (hitTestResults.length) {
                        const hit = hitTestResults[0];
                        // Get the pose in the referenceSpace of the renderer (local-floor or local)
                        const pose = hit.getPose(referenceSpace);

                        if (model && !model.userData.isPlaced) {
                            // Place the model at the hit test location
                            model.position.copy(pose.transform.position);
                            model.quaternion.copy(pose.transform.orientation); // Also apply rotation
                            model.userData.isPlaced = true;
                            console.log("Model successfully placed in AR!");
                        }
                    }
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>