<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Model Viewer</title>
  <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.0.0/model-viewer.min.js"></script>
  <link rel="stylesheet" href="modelviewer_style.css">
  <link rel="stylesheet" href="https://use.typekit.net/zfi8dmc.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap">
</head>

<body>
  <model-viewer ar id="modelViewer"
    shadow-intensity="1"
    shadow-softness="1"
    camera-controls
    touch-action="pan-y, pan-x, none"
    camera-orbit="-25deg 75deg auto"
    scale="1 1 1"
    orbit-sensitivity="2"
    ar-modes="webxr scene-viewer quick-look">

    <button style="background-color:rgb(0,0,0)" slot="hotspot-dot+X-Y+Z" class="dot" data-position="1 -1 1" data-normal="1 0 0"></button>
    <button slot="hotspot-dim+X-Y" class="dim" data-position="1 -1 0" data-normal="1 0 0"></button>
    <button style="background-color:rgb(0,0,0)" slot="hotspot-dot+X-Y-Z" class="dot" data-position="1 -1 -1" data-normal="1 0 0"></button>
    <button slot="hotspot-dim+X-Z" class="dim" data-position="1 0 -1" data-normal="1 0 0"></button>
    <button style="background-color:rgb(0,0,0)" slot="hotspot-dot+X+Y-Z" class="dot" data-position="1 1 -1" data-normal="0 1 0"></button>
    <button slot="hotspot-dim+Y-Z" class="dim" data-position="0 -1 -1" data-normal="0 1 0"></button>
    <button style="background-color:rgb(0,0,0)" slot="hotspot-dot-X+Y-Z" class="dot" data-position="-1 1 -1" data-normal="0 1 0"></button>
    <button slot="hotspot-dim-X-Z" class="dim" data-position="-1 0 -1" data-normal="-1 0 0"></button>
    <button style="background-color:rgb(0,0,0)" slot="hotspot-dot-X-Y-Z" class="dot" data-position="-1 -1 -1" data-normal="-1 0 0"></button>
    <button slot="hotspot-dim-X-Y" class="dim" data-position="-1 -1 0" data-normal="-1 0 0"></button>
    <button style="background-color:rgb(0,0,0)" slot="hotspot-dot-X-Y+Z" class="dot" data-position="-1 -1 1" data-normal="-1 0 0"></button>
    <svg id="dimLines" width="100%" height="100%" class="dimensionLineContainer">
      <line class="dimensionLine"></line>
      <line class="dimensionLine"></line>
      <line class="dimensionLine"></line>
      <line class="dimensionLine"></line>
      <line class="dimensionLine"></line>
    </svg>

    <img id="ar-button" src="icon/arbtn.png" slot="ar-button" alt="arbtn">

  </model-viewer>

  <div id="buttonsGRP">
    <a href="newMenu.html">
      <img class="return" src="icon/returnbtn.png" alt="return">
    </a>
    <img class="specification" src="icon/infobtn.png" alt="specification" id="specButton">
  </div>

  <div id="arOverlay" class="ar-overlay">
    <div class="loadingText">
      <img src="icon/explanation.png">
    </div>
  </div>

  <div class="spec-overlay" id="specOverlay">
    <h2>製品仕様</h2>
    <p>・概要 逆円錐型のケーシング内で回転するパドルによって 粉体に強力な衝撃・せん断力を与え、攪拌・分散し、 精密混合を行うバッチ式の高速せん断型混合機です。 ・特長 短い時間で均一な混合が可能</p>
    <a id="modelLink" href="#" target="_blank">製品仕様</a>

    <div id="iframeWrapper">
      <button id="closeIframeBtn">×</button>
      <iframe title="model" id="modelIframe"></iframe>
    </div>

    <img src="icon/returnbtn.png" class="close-spec" id="closeSpec">
  </div>

  <script type="module">
    const modelViewer = document.getElementById('modelViewer');
    const urlParams = new URLSearchParams(window.location.search);
    const modelUrl = urlParams.get('model');
    const modelKey = modelUrl ? modelUrl.split('/').pop().split('.')[0] : "";

    const specButton = document.getElementById('specButton');
    const specOverlay = document.getElementById('specOverlay');
    const closeSpec = document.getElementById('closeSpec');
    const modelLink = document.getElementById('modelLink');
    const iframeWrapper = document.getElementById('iframeWrapper');
    const modelIframe = document.getElementById('modelIframe');
    const closeIframeBtn = document.getElementById('closeIframeBtn');

    // AR Overlay elements and state
    const arButton = document.querySelector('#ar-button'); // your visible AR button
    const arOverlay = document.getElementById('arOverlay');
    let arJustStarted = false;
    let arTimeout = null;

    // --- Initial Model Load ---
    if (modelUrl) {
      modelViewer.setAttribute('src', modelUrl);
    } else {
      console.warn("No model URL provided in the query string. Using a default or ensure your newMenu.html links correctly.");
      // You might want to set a default model here if none is provided
      // modelViewer.setAttribute('src', 'models/default.glb');
    }

    // --- Functions for Hotspot Dimensions (from model-viewer documentation) ---
    function drawLine(svgLine, dotHotspot1, dotHotspot2, dimensionHotspot) {
      if (dotHotspot1 && dotHotspot2) {
        svgLine.setAttribute('x1', dotHotspot1.canvasPosition.x);
        svgLine.setAttribute('y1', dotHotspot1.canvasPosition.y);
        svgLine.setAttribute('x2', dotHotspot2.canvasPosition.x);
        svgLine.setAttribute('y2', dotHotspot2.canvasPosition.y);

        if (dimensionHotspot && !dimensionHotspot.facingCamera) {
          svgLine.classList.add('hide');
        } else {
          svgLine.classList.remove('hide');
        }
      }
    }

    const dimLines = modelViewer.querySelectorAll('line');

    const renderSVG = () => {
      drawLine(dimLines[0], modelViewer.queryHotspot('hotspot-dot+X-Y+Z'), modelViewer.queryHotspot('hotspot-dot+X-Y-Z'), modelViewer.queryHotspot('hotspot-dim+X-Y'));
      drawLine(dimLines[1], modelViewer.queryHotspot('hotspot-dot+X-Y-Z'), modelViewer.queryHotspot('hotspot-dot+X+Y-Z'), modelViewer.queryHotspot('hotspot-dim+X-Z'));
      drawLine(dimLines[2], modelViewer.queryHotspot('hotspot-dot+X+Y-Z'), modelViewer.queryHotspot('hotspot-dot-X+Y-Z')); // always visible
      drawLine(dimLines[3], modelViewer.queryHotspot('hotspot-dot-X+Y-Z'), modelViewer.queryHotspot('hotspot-dot-X-Y-Z'), modelViewer.queryHotspot('hotspot-dim-X-Z'));
      drawLine(dimLines[4], modelViewer.queryHotspot('hotspot-dot-X-Y-Z'), modelViewer.queryHotspot('hotspot-dot-X-Y+Z'), modelViewer.queryHotspot('hotspot-dim-X-Y'));
    };

    // --- Event Listeners and Logic ---

    // Model loaded and dimensions are ready
    modelViewer.addEventListener('load', () => {
      const center = modelViewer.getBoundingBoxCenter();
      const size = modelViewer.getDimensions();

      const x2 = size.x / 2;
      const y2 = size.y / 2;
      const z2 = size.z / 2;

      // Update hotspot positions and text based on model dimensions
      modelViewer.updateHotspot({ name: 'hotspot-dot+X-Y+Z', position: `${center.x + x2} ${center.y - y2} ${center.z + z2}` });
      modelViewer.updateHotspot({ name: 'hotspot-dim+X-Y', position: `${center.x + x2 * 1.2} ${center.y - y2 * 1.1} ${center.z}` });
      modelViewer.querySelector('button[slot="hotspot-dim+X-Y"]').textContent = `${(size.z * 1.0).toFixed(1)} m`;

      modelViewer.updateHotspot({ name: 'hotspot-dot+X-Y-Z', position: `${center.x + x2} ${center.y - y2} ${center.z - z2}` });
      modelViewer.updateHotspot({ name: 'hotspot-dim+X-Z', position: `${center.x + x2 * 1.2} ${center.y} ${center.z - z2 * 1.2}` });
      modelViewer.querySelector('button[slot="hotspot-dim+X-Z"]').textContent = `${(size.y * 1.0).toFixed(1)} m`;

      modelViewer.updateHotspot({ name: 'hotspot-dot+X+Y-Z', position: `${center.x + x2} ${center.y + y2} ${center.z - z2}` });
      modelViewer.updateHotspot({ name: 'hotspot-dim+Y-Z', position: `${center.x} ${center.y + y2 * 1.1} ${center.z - z2 * 1.1}` });
      modelViewer.querySelector('button[slot="hotspot-dim+Y-Z"]').textContent = `${(size.x * 1.0).toFixed(1)} m`;

      modelViewer.updateHotspot({ name: 'hotspot-dot-X+Y-Z', position: `${center.x - x2} ${center.y + y2} ${center.z - z2}` });
      modelViewer.updateHotspot({ name: 'hotspot-dim-X-Z', position: `${center.x - x2 * 1.2} ${center.y} ${center.z - z2 * 1.2}` });
      modelViewer.querySelector('button[slot="hotspot-dim-X-Z"]').textContent = `${(size.y * 1.0).toFixed(1)} m`;

      modelViewer.updateHotspot({ name: 'hotspot-dot-X-Y-Z', position: `${center.x - x2} ${center.y - y2} ${center.z - z2}` });
      modelViewer.updateHotspot({ name: 'hotspot-dim-X-Y', position: `${center.x - x2 * 1.2} ${center.y - y2 * 1.1} ${center.z}` });
      modelViewer.querySelector('button[slot="hotspot-dim-X-Y"]').textContent = `${(size.z * 1.0).toFixed(1)} m`;

      modelViewer.updateHotspot({ name: 'hotspot-dot-X-Y+Z', position: `${center.x - x2} ${center.y - y2} ${center.z + z2}` });

      renderSVG(); // Initial SVG render
      modelViewer.addEventListener('camera-change', renderSVG); // Update SVG on camera change

      // Adjust camera distance for optimal view
      const maxDim = Math.max(size.x, size.y, size.z);
      const suggestedDistance = maxDim * 1.5; // Adjusted factor to be more reasonable
      modelViewer.cameraOrbit = `0deg 75deg ${suggestedDistance}m`;

      // Set shadow light direction
      const light = modelViewer.scene.shadowLight;
      light.direction.set(0.5, -1, 0.5);
    });

    // --- AR Overlay Logic ---
    function startAR() {
      arOverlay.style.display = 'none';
      arJustStarted = false;
      modelViewer.activateAR(); // Correctly activates AR mode
    }

    arButton.addEventListener('click', (event) => {
      if (!arJustStarted) {
        event.preventDefault(); // Prevent model-viewer's default AR activation
        event.stopPropagation(); // Stop event propagation

        arOverlay.style.display = 'flex';
        arJustStarted = true;

        // Set a timeout to automatically start AR after 5 seconds
        arTimeout = setTimeout(() => {
          startAR();
        }, 5000);
      }
    });

    arOverlay.addEventListener('click', () => {
      if (arJustStarted) {
        clearTimeout(arTimeout); // Clear timeout if user taps early
        startAR();
      }
    });

    modelViewer.addEventListener('ar-status', (event) => {
      // Hide AR overlay when AR session ends
      if (event.detail.status === 'not-presenting') {
        arOverlay.style.display = 'none';
        arJustStarted = false;
        clearTimeout(arTimeout); // Clear any pending timeout
      }
    });

    // --- Specification Overlay Logic (consolidated and using fetch) ---
    fetch('modelSpecs.json')
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then(modelSpecs => {
        if (modelKey && modelSpecs[modelKey]) {
          const spec = modelSpecs[modelKey];
          specOverlay.querySelector('h2').innerHTML = spec.title;
          specOverlay.querySelector('p').innerHTML = spec.description;

          if (spec.link) {
            modelLink.style.display = 'inline';
            modelLink.onclick = (e) => {
              e.preventDefault(); // Prevents opening in a new tab
              modelIframe.src = spec.link;
              iframeWrapper.style.display = 'block';
            };
          } else {
            modelLink.style.display = 'none';
            iframeWrapper.style.display = 'none';
          }
        } else {
          specOverlay.querySelector('h2').textContent = "仕様情報がありません";
          specOverlay.querySelector('p').textContent = "このモデルの仕様はまだ登録されていません。";
          modelLink.style.display = 'none';
          iframeWrapper.style.display = 'none';
        }
      })
      .catch(error => {
        console.error('Error loading modelSpecs.json:', error);
        specOverlay.querySelector('h2').textContent = "エラー";
        specOverlay.querySelector('p').textContent = "仕様情報の読み込みに失敗しました。";
        modelLink.style.display = 'none';
        iframeWrapper.style.display = 'none';
      });

    specButton.addEventListener('click', () => {
      specOverlay.style.display = 'flex';
    });

    closeSpec.addEventListener('click', () => {
      specOverlay.style.display = 'none';
      iframeWrapper.style.display = 'none'; // Hide iframe when closing spec overlay
      modelIframe.src = ""; // Clear iframe content
    });

    closeIframeBtn.addEventListener('click', () => {
      iframeWrapper.style.display = 'none';
      modelIframe.src = ''; // Clear iframe content
    });

    // --- Prevent duplicate AR buttons in fullscreen (model-viewer specific) ---
    modelViewer.addEventListener('fullscreenchange', () => {
      const arButtons = modelViewer.shadowRoot?.querySelectorAll('button[slot="ar-button"]');
      if (arButtons && arButtons.length > 1) {
        for (let i = 1; i < arButtons.length; i++) {
          arButtons[i].remove();
        }
      }
    });

  </script>
</body>
</html>