<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js AR with iOS Quick Look</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { margin: 0; overflow: hidden; }
    #start-ar {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      background: #0088ff;
      color: white;
      border: none;
      font-size: 18px;
      border-radius: 8px;
      cursor: pointer;
      z-index: 10;
    }
  </style>
</head>
<body>
  <a id="ios-ar-link" rel="ar" href="model1.usdz" style="display: none;">
    <img src="quicklook-button.png" alt="View in AR" />
  </a>
  <button id="start-ar">Enter AR</button>

  <script>
    // Detect iOS
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    if (isIOS) {
      document.getElementById('start-ar').style.display = 'none';
      const iosLink = document.getElementById('ios-ar-link');
      iosLink.style.display = 'block';
      iosLink.click(); // auto open Quick Look
    }
  </script>

  <script type="module">
    if (!/iPad|iPhone|iPod/.test(navigator.userAgent)) {
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';
      import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/loaders/GLTFLoader.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/webxr/ARButton.js';

      let camera, scene, renderer, controller, reticle, model;
      let currentSession = null;
      let initialPinchDistance = null;
      let lastRotation = 0;

      init();

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera();

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        scene.add(light);

        const loader = new GLTFLoader();
        loader.load('model1.glb', (gltf) => {
          model = gltf.scene;
          model.visible = false;
          model.scale.set(0.2, 0.2, 0.2);
          scene.add(model);
        });

        reticle = new THREE.Mesh(
          new THREE.RingGeometry(0.1, 0.11, 32).rotateX(-Math.PI / 2),
          new THREE.MeshBasicMaterial({ color: 0x00ffff })
        );
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);

        controller = renderer.xr.getController(0);
        controller.addEventListener('select', () => {
          if (reticle.visible && model) {
            model.position.setFromMatrixPosition(reticle.matrix);
            model.visible = true;
          }
        });
        scene.add(controller);

        document.getElementById('start-ar').addEventListener('click', () => {
          navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['hit-test', 'dom-overlay'],
            domOverlay: { root: document.body }
          }).then(onSessionStarted);
        });

        renderer.setAnimationLoop(render);
        setupTouchGestures();
      }

      function onSessionStarted(session) {
        renderer.xr.setSession(session);
        currentSession = session;

        const refSpace = renderer.xr.getReferenceSpace();
        session.requestReferenceSpace('viewer').then((viewerRefSpace) => {
          session.requestHitTestSource({ space: viewerRefSpace }).then((hitTestSource) => {
            session.addEventListener('end', () => {
              hitTestSource.cancel();
              currentSession = null;
            });

            renderer.setAnimationLoop((timestamp, frame) => {
              if (frame) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                if (hitTestResults.length > 0) {
                  const hit = hitTestResults[0];
                  const pose = hit.getPose(refSpace);
                  reticle.visible = true;
                  reticle.matrix.fromArray(pose.transform.matrix);
                } else {
                  reticle.visible = false;
                }
              }
              renderer.render(scene, camera);
            });
          });
        });

        document.getElementById('start-ar').style.display = 'none';
      }

      function render() {
        renderer.render(scene, camera);
      }

      function setupTouchGestures() {
        let isDragging = false;
        let previousTouch = null;

        window.addEventListener('touchstart', (e) => {
          if (!model || !model.visible) return;

          if (e.touches.length === 1) {
            isDragging = true;
            previousTouch = e.touches[0];
          } else if (e.touches.length === 2) {
            initialPinchDistance = getTouchDistance(e.touches);
            lastRotation = getTouchAngle(e.touches);
          }
        });

        window.addEventListener('touchmove', (e) => {
          if (!model || !model.visible) return;

          if (e.touches.length === 1 && isDragging) {
            const deltaX = e.touches[0].pageX - previousTouch.pageX;
            model.rotation.y += deltaX * 0.01;
            previousTouch = e.touches[0];
          } else if (e.touches.length === 2) {
            const newDistance = getTouchDistance(e.touches);
            const newAngle = getTouchAngle(e.touches);

            if (initialPinchDistance !== null) {
              const scaleFactor = newDistance / initialPinchDistance;
              model.scale.multiplyScalar(scaleFactor);
              initialPinchDistance = newDistance;
            }

            if (lastRotation !== null) {
              const angleDiff = newAngle - lastRotation;
              model.rotation.y += angleDiff * 0.01;
              lastRotation = newAngle;
            }
          }
        });

        window.addEventListener('touchend', (e) => {
          isDragging = false;
          previousTouch = null;
          if (e.touches.length < 2) {
            initialPinchDistance = null;
            lastRotation = 0;
          }
        });

        function getTouchDistance(touches) {
          const dx = touches[0].pageX - touches[1].pageX;
          const dy = touches[0].pageY - touches[1].pageY;
          return Math.sqrt(dx * dx + dy * dy);
        }

        function getTouchAngle(touches) {
          const dx = touches[1].pageX - touches[0].pageX;
          const dy = touches[1].pageY - touches[0].pageY;
          return Math.atan2(dy, dx);
        }
      }
    }
  </script>
</body>
</html>
