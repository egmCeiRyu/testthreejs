<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3D Model Viewer with Measurement and Custom AR</title>

  <!-- model-viewer -->
  <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.0.0/model-viewer.min.js"></script>

  <style>
    body, html {
      margin: 0; padding: 0; height: 100%; overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    }
    model-viewer {
      width: 100%; height: 100vh; display: block;
    }
    #threejs-ar-container {
      display: none; width: 100%; height: 100vh; position: absolute; top: 0; left: 0; z-index: 10;
    }
    #exit-ar-button {
      position: fixed; top: 20px; left: 20px;
      padding: 10px 15px;
      background: rgba(0,0,0,0.7);
      color: white;
      border: none;
      cursor: pointer;
      display: none;
      z-index: 15;
      border-radius: 4px;
    }
    .dot {
      width: 15px; height: 15px; border-radius: 50%;
      background-color: black; opacity: 0.8;
      border: 1px solid white;
      cursor: default;
    }
    .dim {
      background-color: rgba(255, 255, 255, 0.7);
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 14px;
      user-select: none;
    }
    .dimensionLineContainer {
      pointer-events: none;
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      overflow: visible;
      z-index: 5;
    }
    .dimensionLine {
      stroke: black;
      stroke-width: 2;
    }
    .hide {
      display: none;
    }
  </style>
</head>

<body>
  <model-viewer
    id="modelViewer"
    shadow-intensity="1"
    shadow-softness="1"
    camera-controls
    touch-action="pan-y, pan-x, none"
    camera-orbit="-25deg 75deg auto"
    scale="1 1 1"
    orbit-sensitivity="2"
    ar-modes="webxr scene-viewer quick-look"
    src=""
  >
    <!-- Measurement hotspots -->
    <button slot="hotspot-dot+X-Y+Z" class="dot" data-position="1 -1 1" data-normal="1 0 0"></button>
    <button slot="hotspot-dim+X-Y" class="dim" data-position="1 -1 0" data-normal="1 0 0"></button>
    <button slot="hotspot-dot+X-Y-Z" class="dot" data-position="1 -1 -1" data-normal="1 0 0"></button>
    <button slot="hotspot-dim+X-Z" class="dim" data-position="1 0 -1" data-normal="1 0 0"></button>
    <button slot="hotspot-dot+X+Y-Z" class="dot" data-position="1 1 -1" data-normal="0 1 0"></button>
    <button slot="hotspot-dim+Y-Z" class="dim" data-position="0 -1 -1" data-normal="0 1 0"></button>
    <button slot="hotspot-dot-X+Y-Z" class="dot" data-position="-1 1 -1" data-normal="0 1 0"></button>
    <button slot="hotspot-dim-X-Z" class="dim" data-position="-1 0 -1" data-normal="-1 0 0"></button>
    <button slot="hotspot-dot-X-Y-Z" class="dot" data-position="-1 -1 -1" data-normal="-1 0 0"></button>
    <button slot="hotspot-dim-X-Y" class="dim" data-position="-1 -1 0" data-normal="-1 0 0"></button>
    <button slot="hotspot-dot-X-Y+Z" class="dot" data-position="-1 -1 1" data-normal="-1 0 0"></button>

    <svg id="dimLines" width="100%" height="100%" class="dimensionLineContainer" pointer-events="none" >
      <line class="dimensionLine"></line>
      <line class="dimensionLine"></line>
      <line class="dimensionLine"></line>
      <line class="dimensionLine"></line>
      <line class="dimensionLine"></line>
    </svg>

    <button slot="ar-button" id="custom-ar-button" style="background-color: black; color: white;">
      Enter AR (Custom)
    </button>
  </model-viewer>

  <div id="threejs-ar-container"></div>
  <button id="exit-ar-button">Exit AR</button>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/loaders/GLTFLoader.js';

    const urlParams = new URLSearchParams(window.location.search);
    const modelUrl = urlParams.get('model');
    const modelViewer = document.getElementById('modelViewer');
    const arButton = document.getElementById('custom-ar-button');
    const arContainer = document.getElementById('threejs-ar-container');
    const exitArBtn = document.getElementById('exit-ar-button');

    // Set model-viewer src from URL
    if (modelUrl) {
      modelViewer.setAttribute('src', modelUrl);
    } else {
      console.warn('No model URL provided in query parameters.');
    }

    // Measurement functions
    const dimLines = modelViewer.querySelectorAll('line');

    function drawLine(svgLine, dot1, dot2, dimensionHotspot) {
      if (dot1 && dot2) {
        svgLine.setAttribute('x1', dot1.canvasPosition.x);
        svgLine.setAttribute('y1', dot1.canvasPosition.y);
        svgLine.setAttribute('x2', dot2.canvasPosition.x);
        svgLine.setAttribute('y2', dot2.canvasPosition.y);

        if (dimensionHotspot && !dimensionHotspot.facingCamera) {
          svgLine.classList.add('hide');
        } else {
          svgLine.classList.remove('hide');
        }
      }
    }

    function renderSVG() {
      drawLine(dimLines[0], modelViewer.queryHotspot('hotspot-dot+X-Y+Z'), modelViewer.queryHotspot('hotspot-dot+X-Y-Z'), modelViewer.queryHotspot('hotspot-dim+X-Y'));
      drawLine(dimLines[1], modelViewer.queryHotspot('hotspot-dot+X-Y-Z'), modelViewer.queryHotspot('hotspot-dot+X+Y-Z'), modelViewer.queryHotspot('hotspot-dim+X-Z'));
      drawLine(dimLines[2], modelViewer.queryHotspot('hotspot-dot+X+Y-Z'), modelViewer.queryHotspot('hotspot-dot-X+Y-Z'));
      drawLine(dimLines[3], modelViewer.queryHotspot('hotspot-dot-X+Y-Z'), modelViewer.queryHotspot('hotspot-dot-X-Y-Z'), modelViewer.queryHotspot('hotspot-dim-X-Z'));
      drawLine(dimLines[4], modelViewer.queryHotspot('hotspot-dot-X-Y-Z'), modelViewer.queryHotspot('hotspot-dot-X-Y+Z'), modelViewer.queryHotspot('hotspot-dim-X-Y'));
    }

    modelViewer.addEventListener('load', () => {
      const center = modelViewer.getBoundingBoxCenter();
      const size = modelViewer.getDimensions();

      const x2 = size.x / 2;
      const y2 = size.y / 2;
      const z2 = size.z / 2;

      modelViewer.updateHotspot({
        name: 'hotspot-dot+X-Y+Z',
        position: `${center.x + x2} ${center.y - y2} ${center.z + z2}`
      });
      modelViewer.updateHotspot({
        name: 'hotspot-dim+X-Y',
        position: `${center.x + x2 * 1.2} ${center.y - y2 * 1.1} ${center.z}`
      });
      modelViewer.querySelector('button[slot="hotspot-dim+X-Y"]').textContent = `${(size.z).toFixed(1)} m`;

      modelViewer.updateHotspot({
        name: 'hotspot-dot+X-Y-Z',
        position: `${center.x + x2} ${center.y - y2} ${center.z - z2}`
      });
      modelViewer.updateHotspot({
        name: 'hotspot-dim+X-Z',
        position: `${center.x + x2 * 1.2} ${center.y} ${center.z - z2 * 1.2}`
      });
      modelViewer.querySelector('button[slot="hotspot-dim+X-Z"]').textContent = `${(size.y).toFixed(1)} m`;

      modelViewer.updateHotspot({
        name: 'hotspot-dot+X+Y-Z',
        position: `${center.x + x2} ${center.y + y2} ${center.z - z2}`
      });
      modelViewer.updateHotspot({
        name: 'hotspot-dim+Y-Z',
        position: `${center.x} ${center.y + y2 * 1.1} ${center.z - z2 * 1.1}`
      });
      modelViewer.querySelector('button[slot="hotspot-dim+Y-Z"]').textContent = `${(size.x).toFixed(1)} m`;

      modelViewer.updateHotspot({
        name: 'hotspot-dot-X+Y-Z',
        position: `${center.x - x2} ${center.y + y2} ${center.z - z2}`
      });
      modelViewer.updateHotspot({
        name: 'hotspot-dim-X-Z',
        position: `${center.x - x2 * 1.2} ${center.y} ${center.z - z2 * 1.2}`
      });
      modelViewer.querySelector('button[slot="hotspot-dim-X-Z"]').textContent = `${(size.y).toFixed(1)} m`;

      modelViewer.updateHotspot({
        name: 'hotspot-dot-X-Y-Z',
        position: `${center.x - x2} ${center.y - y2} ${center.z - z2}`
      });
      modelViewer.updateHotspot({
        name: 'hotspot-dim-X-Y',
        position: `${center.x - x2 * 1.2} ${center.y - y2 * 1.1} ${center.z}`
      });
      modelViewer.querySelector('button[slot="hotspot-dim-X-Y"]').textContent = `${(size.z).toFixed(1)} m`;

      modelViewer.updateHotspot({
        name: 'hotspot-dot-X-Y+Z',
        position: `${center.x - x2} ${center.y - y2} ${center.z + z2}`
      });

      renderSVG();
    });

    modelViewer.addEventListener('camera-change', renderSVG);

    // --- Three.js AR setup ---

    let camera, scene, renderer, controller;
    let reticle;
    let model;
    let hitTestSource = null;
    let hitTestSourceRequested = false;

    function initThreeJsAR() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        0.01,
        20
      );

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      arContainer.appendChild(renderer.domElement);

      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);

      const geometry = new THREE.RingGeometry(0.15, 0.2, 32).rotateX(- Math.PI / 2);
      const material = new THREE.MeshBasicMaterial({ color: 0x0fff00 });
      reticle = new THREE.Mesh(geometry, material);
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      const loader = new GLTFLoader();
      loader.load(
        modelUrl,
        (gltf) => {
          model = gltf.scene;
          model.scale.set(0.5, 0.5, 0.5);
          model.visible = false;
          scene.add(model);
        },
        undefined,
        (error) => {
          console.error('Error loading model for AR:', error);
        }
      );

      controller = renderer.xr.getController(0);
      controller.addEventListener('select', onSelect);
      scene.add(controller);

      window.addEventListener('resize', onWindowResize);

      renderer.setAnimationLoop(render);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onSelect() {
      if (reticle.visible && model) {
        model.position.setFromMatrixPosition(reticle.matrix);
        model.visible = true;
      }
    }

    function render(timestamp, frame) {
      if (frame) {
        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();

        if (!hitTestSourceRequested) {
          session.requestReferenceSpace('viewer').then((refSpace) => {
            session.requestHitTestSource({ space: refSpace }).then((source) => {
              hitTestSource = source;
            });
          });
          session.addEventListener('end', () => {
            hitTestSourceRequested = false;
            hitTestSource = null;
          });
          hitTestSourceRequested = true;
        }

        if (hitTestSource) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);

          if (hitTestResults.length) {
            const hit = hitTestResults[0];
            const pose = hit.getPose(referenceSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
      }

      renderer.render(scene, camera);
    }

    function startThreeJsAR() {
      modelViewer.style.display = 'none';
      arContainer.style.display = 'block';
      exitArBtn.style.display = 'block';

      if (!renderer) {
        initThreeJsAR();
      }

      navigator.xr.requestSession('immersive-ar', {
        requiredFeatures: ['hit-test']
      }).then((session) => {
        renderer.xr.setSession(session);
      }).catch(err => {
        alert('Failed to start AR session: ' + err.message);
        exitThreeJsAR();
      });
    }

    function exitThreeJsAR() {
      if (renderer && renderer.xr.getSession()) {
        renderer.xr.getSession().end();
      }
      arContainer.style.display = 'none';
      exitArBtn.style.display = 'none';
      modelViewer.style.display = 'block';
    }

    arButton.addEventListener('click', () => {
      if (navigator.xr && navigator.xr.isSessionSupported) {
        navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
          if (supported) {
            startThreeJsAR();
          } else {
            alert('AR not supported on this device/browser.');
          }
        });
      } else {
        alert('WebXR not available on this device/browser.');
      }
    });

    exitArBtn.addEventListener('click', exitThreeJsAR);
  </script>
</body>
</html>
